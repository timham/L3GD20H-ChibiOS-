/*
    ChibiOS/RT - Copyright (C) 2006,2007,2008,2009,2010,
                 2011,2012,2013 Giovanni Di Sirio.

    This file is part of ChibiOS/RT.

    ChibiOS/RT is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    ChibiOS/RT is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.


    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ch.h"
#include "hal.h"

#include "../gyro/stm32f3_discovery_l3gd20.h"

/*
 * Maximum speed SPI configuration (18MHz, CPHA=0, CPOL=0, MSb first).
 */
static const SPIConfig hs_spicfg = {
  NULL,
  GPIOE,
  12,
  0,
  SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0
};

/*
 * Low speed SPI configuration (140.625kHz, CPHA=0, CPOL=0, MSb first).
 */
static const SPIConfig ls_spicfg = {
  NULL,
  GPIOE,
  12,
  SPI_CR1_BR_2 | SPI_CR1_BR_1,
  SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0
};

/*
 * SPI TX and RX buffers.
 */ static uint8_t txbuf[512]; static uint8_t rxbuf[512];

/*
 * SPI bus contender 1.
 */

//#define _TEST_LAMP
#define _TEST_L3GD20

 
#if defined(_TEST_LAMP) 
	#undef  _TEST_L3GD20

#elif defined(_TEST_L3GD20)
	#undef  _TEST_LAMP
#endif

typedef enum  DIR {
	N =   GPIOE_LED3_RED,
	NE =  GPIOE_LED5_ORANGE,
	E =   GPIOE_LED7_GREEN,
	SE = GPIOE_LED9_BLUE,
	S =   GPIOE_LED10_RED,
	SW = GPIOE_LED8_ORANGE,
	W =  GPIOE_LED6_GREEN,
	NW =GPIOE_LED4_BLUE
}DIR_t;

bool   assert_check_led(DIR_t pos)
{
	if( (pos =(GPIOE_LED3_RED ||GPIOE_LED4_BLUE || GPIOE_LED5_ORANGE 
		||GPIOE_LED6_GREEN || GPIOE_LED7_GREEN || GPIOE_LED8_ORANGE
		|| GPIOE_LED9_BLUE || GPIOE_LED10_RED)
	     )
	   )
		return  TRUE;
	
	return FALSE;
}

void  searching_led_position(DIR_t  pos)
{
	static uint8_t   cur_pos = 0xff,  prev_pos = 0x00;

	if(assert_check_led(pos) == FALSE)
		return;
	
	cur_pos = pos;
	if(cur_pos != prev_pos) {
		palSetPad(GPIOE, cur_pos);
	}

	if(assert_check_led(prev_pos) == FALSE)
		return;
	
	palClearPad(GPIOE, prev_pos);
	prev_pos = cur_pos;
} 

#define  _S_SPI   SPID1
#define SLEEP_TIME   120

static WORKING_AREA(spi_thread_1_wa, 256);
static msg_t spi_thread_1(void *p) {
  uint8_t   OUT_X_L, OUT_X_H, 
	  OUT_Y_L, OUT_Y_H,
	  OUT_Z_L, OUT_Z_H,
	  WHO_AM_I;

  (void)p;

  chRegSetThreadName("SPI thread 1");
  
  while (TRUE) {
#if  defined(_TEST_L3GD20)
    //	spiAcquireBus(&_S_SPI);              	/* Acquire ownership of the bus.    */

	L3GD20_Read(&WHO_AM_I, L3GD20_WHO_AM_I_ADDR, 1);
	//chThdSleepMilliseconds(90);
	
	L3GD20_Read(&OUT_X_L, L3GD20_OUT_X_L_ADDR, 1);
	L3GD20_Read(&OUT_X_H, L3GD20_OUT_X_H_ADDR, 1);
	L3GD20_Read(&OUT_Y_L, L3GD20_OUT_Y_L_ADDR, 1);
	L3GD20_Read(&OUT_Y_H, L3GD20_OUT_Y_H_ADDR, 1);
	L3GD20_Read(&OUT_Z_L, L3GD20_OUT_Z_L_ADDR, 1);
	L3GD20_Read(&OUT_Z_H, L3GD20_OUT_Z_H_ADDR, 1);

    #if 1 // For Test
	if(WHO_AM_I == 0xD4)
		palSetPad(GPIOE, GPIOE_LED9_BLUE);
    #endif

#if 0
	searching_led_position(E);
	chThdSleepMilliseconds(SLEEP_TIME);
	searching_led_position(SE);
	chThdSleepMilliseconds(SLEEP_TIME);
	searching_led_position(S);
	chThdSleepMilliseconds(SLEEP_TIME);
	searching_led_position(SW);
	chThdSleepMilliseconds(SLEEP_TIME);
	searching_led_position(W);
	chThdSleepMilliseconds(SLEEP_TIME);
#endif

    	spiAcquireBus(&_S_SPI);              	/* Acquire ownership of the bus.    */

#if 0
    	spiStart(&_S_SPI, &hs_spicfg);      	/* Setup transfer parameters.       */
    	spiSelect(&_S_SPI);			/* Slave Select assertion.          */

	//palSetPad(GPIOE, GPIOE_L3GD20_INT1);
	//chThdSleepMilliseconds(0);
	//test_println(&WHO_AM_I);

    	spiExchange(&_S_SPI, 512, txbuf, rxbuf);/* Atomic transfer operations.      */
    	spiUnselect(&_S_SPI);                	/* Slave Select de-assertion.       */
    	spiReleaseBus(&_S_SPI);              	/* Ownership release.               */
    #endif

#else
    #if defined(_TEST_LAMP)
	spiAcquireBus(&SPID1);			/* Acquire ownership of the bus.    */
	palSetPad(GPIOE, GPIOE_LED10_RED);	/* LED ON.			    */
	spiStart(&SPID1, &hs_spicfg);		/* Setup transfer parameters.       */
	spiSelect(&SPID1);                      /* Slave Select assertion.          */
        spiExchange(&SPID1, 512, txbuf, rxbuf); /* Atomic transfer operations.      */
	spiUnselect(&SPID1);
	spiReleaseBus(&SPID1);
    #endif
#endif
  }
  return 0;
}

/*
 * SPI bus contender 1 0r 2.
 */
static WORKING_AREA(spi_thread_2_wa, 256);
static msg_t spi_thread_2(void *p) {

  (void)p;

  chRegSetThreadName("SPI thread 2");

  #if defined(_TEST_L3GD20)
  while (TRUE) {
    	spiAcquireBus(&_S_SPI);              /* Acquire ownership of the bus.    */
    	palClearPad(GPIOE, GPIOE_LED5_ORANGE);/* LED OFF.                         */
	chThdSleepMilliseconds(90);
    	spiStart(&_S_SPI, &hs_spicfg);       /* Setup transfer parameters.       */
    	spiSelect(&_S_SPI);                  /* Slave Select assertion.          */	
    	spiExchange(&_S_SPI, 512,
        	        txbuf, rxbuf);          /* Atomic transfer operations.      */
    	spiUnselect(&_S_SPI);                /* Slave Select de-assertion.       */
    	spiReleaseBus(&_S_SPI);              /* Ownership release.               */
  }

  #elif defined(_TEST_LAMP)
  while (TRUE) {
    	spiAcquireBus(&SPID1);              	/* Acquire ownership of the bus.    */
    	palClearPad(GPIOE, GPIOE_LED10_RED);	/* LED OFF.                         */
    	spiStart(&SPID1, &hs_spicfg);       	/* Setup transfer parameters.       */
    	spiSelect(&SPID1);                  	/* Slave Select assertion.          */	
    	spiExchange(&SPID1, 512,
		txbuf, rxbuf);          	/* Atomic transfer operations.      */
    	spiUnselect(&SPID1);                	/* Slave Select de-assertion.       */
    	spiReleaseBus(&SPID1);              	/* Ownership release.               */
  }
  
  #endif
  return 0;
}
/*
 * This is a periodic thread that does absolutely nothing except flashing
 * a LED.
 */

 
static WORKING_AREA(blinker_wa, 128);
static msg_t blinker(void *arg) {

  (void)arg;
  chRegSetThreadName("blinker");
  while (TRUE) {
	palSetPad(GPIOE, GPIOE_LED3_RED);
	chThdSleepMilliseconds(SLEEP_TIME);
	palClearPad(GPIOE, GPIOE_LED3_RED);
	chThdSleepMilliseconds(SLEEP_TIME);

	palSetPad(GPIOE, GPIOE_LED5_ORANGE);
	chThdSleepMilliseconds(SLEEP_TIME);
	palClearPad(GPIOE, GPIOE_LED5_ORANGE);

	palSetPad(GPIOE, GPIOE_LED7_GREEN);
	chThdSleepMilliseconds(SLEEP_TIME);
	palClearPad(GPIOE, GPIOE_LED7_GREEN);

	palSetPad(GPIOE, GPIOE_LED9_BLUE);
	chThdSleepMilliseconds(SLEEP_TIME);
	palClearPad(GPIOE, GPIOE_LED9_BLUE);
		
	palSetPad(GPIOE, GPIOE_LED10_RED);
	chThdSleepMilliseconds(SLEEP_TIME);
	palClearPad(GPIOE, GPIOE_LED10_RED);

	palSetPad(GPIOE, GPIOE_LED8_ORANGE);
	chThdSleepMilliseconds(SLEEP_TIME);
	palClearPad(GPIOE, GPIOE_LED8_ORANGE);

	palSetPad(GPIOE, GPIOE_LED6_GREEN);
	chThdSleepMilliseconds(SLEEP_TIME);
	palClearPad(GPIOE, GPIOE_LED6_GREEN);

	palSetPad(GPIOE, GPIOE_LED4_BLUE);
	chThdSleepMilliseconds(SLEEP_TIME);
	palClearPad(GPIOE, GPIOE_LED4_BLUE);
  }
}

/*
 * Application entry point.
 */

int main(void) {
  unsigned i;

  /*
   * System initializations.
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */

   
  	halInit();
  	chSysInit();

#if  defined(_TEST_L3GD20)

      	L3GD20_InitTypeDef G20_REG20_23;

      	G20_REG20_23.Power_Mode = 0x1 << 7; // Power mode setting
      	G20_REG20_23.Output_DataRate= 0x0 << 6;
      	G20_REG20_23.Axes_Enable = 0x01 | 0x01 << 1 | 0x01 << 2;
      	G20_REG20_23.Band_Width = 0x00 << 4;
      	G20_REG20_23.BlockData_Update = 0x80 & 0x00;
      	G20_REG20_23.Endianness = 0x40 & 0x40;
      	G20_REG20_23.Full_Scale = 0x20 & 0x00;

     	L3GD20_Init(&G20_REG20_23);
#endif

  /*
   * SPI2 I/O pins setup.
   */
#if 1   
  	palSetPadMode(GPIOB, 13, PAL_MODE_ALTERNATE(5) |
                           PAL_STM32_OSPEED_HIGHEST);       /* New SCK.     */
  	palSetPadMode(GPIOB, 14, PAL_MODE_ALTERNATE(5) |
                           PAL_STM32_OSPEED_HIGHEST);       /* New MISO.    */
  	palSetPadMode(GPIOB, 15, PAL_MODE_ALTERNATE(5) |
                           PAL_STM32_OSPEED_HIGHEST);       /* New MOSI.    */
  	palSetPadMode(GPIOB, 12, PAL_MODE_OUTPUT_PUSHPULL |
                           PAL_STM32_OSPEED_HIGHEST);       /* New CS.      */
  	palSetPad(GPIOB, 12);
#endif

  	/*
   	* Prepare transmit pattern.
   	*/

  	for (i = 0; i < sizeof(txbuf); i++)
    		txbuf[i] = (uint8_t)i;

  	/*
   	* Starting the transmitter and receiver threads.
   	*/

  	chThdCreateStatic(spi_thread_1_wa, sizeof(spi_thread_1_wa),
                    NORMALPRIO + 1, spi_thread_1, NULL);
  
  	chThdCreateStatic(spi_thread_2_wa, sizeof(spi_thread_2_wa),
                    NORMALPRIO + 1, spi_thread_2, NULL);


  	/*
   	* Starting the blinker thread.
   	*/

	#if 0     
  	chThdCreateStatic(blinker_wa, sizeof(blinker_wa),
                    NORMALPRIO-1, blinker, NULL);
	#endif

  	/*
   	* Normal main() thread activity, in this demo it does nothing.
   	*/

  	while (TRUE) {
    		chThdSleepMilliseconds(500);
  	}

  	return 0;
}
